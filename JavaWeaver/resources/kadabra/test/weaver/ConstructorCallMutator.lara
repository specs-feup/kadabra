import lara.mutation.Mutator;
import lara.Io;

import weaver.Query;

aspectdef ConstructorCallMutatorTest

	var mutator = new ConstructorCallMutator(WeaverJps.root());

	while(mutator.hasMutations()) {
		// Mutate
		mutator.mutate();

		saveFile();
		// Restore operator
		mutator.restore();
		

	}


end


function saveFile(){
	var outputFolder = Io.mkdir("./mutatedFilesTest/");
	Io.deleteFolderContents(outputFolder);

	// Write modified code
	Weaver.writeCode(outputFolder);
		
	// Print contents
	for(var mutatedFile of Io.getFiles(outputFolder, "*.java") ) {
		println("<File '" + mutatedFile.getName() + "'>");
		println(Io.readFile(mutatedFile));
	}
		
	Io.deleteFolder(outputFolder);		
}


/**
 *  @param {$joinPoint} $joinPoint - A join point to use as startpoint to search for constructor calls to replace with null.
 */
var ConstructorCallMutator = function($joinPoint) {
	// Parent constructor
    Mutator.call(this);

	if($joinPoint === undefined) {
		$joinPoint = WeaverJps.root();
	}

	// Instance variables
	this.$joinPoint = $joinPoint;
	this.extraArgs = arrayFromArgs(arguments, 1);
	
	this.toMutate = [];
	this.totalMutations = -1;
	this.currentIndex = 0;
	
	this.$referenceParent = undefined;
	this.$originalParent = undefined;
	

	// Checks
	if(this.extraArgs.length != 0)
		throw "Expected only 1 argument but received " + (this.extraArgs.length + 1);

	for($ref of WeaverJps.searchFrom(this.$joinpoint, 'reference').get().reverse()) {
		// Check it is a constructor call reference
		if($ref.name === "<init>" && $ref.type === "Executable" && $ref.parent.srcCode !== "super()")
			this.toMutate.push($ref);
	}
	
	this.totalMutations = this.toMutate.length;
	if(this.totalMutations == 0)
		println("Found no suitable code to mutate");

};

// Inheritance
ConstructorCallMutator.prototype = Object.create(Mutator.prototype);


/*** IMPLEMENTATION OF INSTANCE METHODS ***/

ConstructorCallMutator.prototype.hasMutations = function() {
	return this.currentIndex < this.totalMutations;
}


ConstructorCallMutator.prototype._mutatePrivate = function() {
	this.$referenceParent = this.toMutate[this.currentIndex++].parent;

	this.$originalParent = this.$referenceParent.copy();
	this.$referenceParent = this.$referenceParent.insertReplace("null");

	println("/*--------------------------------------*/");
	println("Mutating operator n."+ this.currentIndex + ": "+ this.$originalParent
		+" to "+ this.$referenceParent);
	println("/*--------------------------------------*/");

}

ConstructorCallMutator.prototype._restorePrivate = function() {
	this.$referenceParent = this.$referenceParent.insertReplace(this.$originalParent);
	this.$originalParent = undefined;
	this.$referenceParent = undefined;
}
