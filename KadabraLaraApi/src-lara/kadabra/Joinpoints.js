///////////////////////////////////////////////////
// This file is generated by build-interfaces.js //
///////////////////////////////////////////////////
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-duplicate-type-constituents */
import { LaraJoinPoint, registerJoinpointMapper, wrapJoinPoint, unwrapJoinPoint, } from "@specs-feup/lara/api/LaraJoinPoint.js";
export class Joinpoint extends LaraJoinPoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: null,
    };
    /**
     * An array of the annotations of this node
     */
    get annotations() { return wrapJoinPoint(this._javaObject.getAnnotations()); }
    /**
     * A string representation of the AST corresponding to this node
     */
    get ast() { return wrapJoinPoint(this._javaObject.getAst()); }
    /**
     * Alias of attribute 'parent'
     */
    get astParent() { return wrapJoinPoint(this._javaObject.getAstParent()); }
    /**
     * Returns an array with the children of the node
     */
    get children() { return wrapJoinPoint(this._javaObject.getChildren()); }
    /**
     * The source code corresponding to this join point
     */
    get code() { return wrapJoinPoint(this._javaObject.getCode()); }
    get descendants() { return wrapJoinPoint(this._javaObject.getDescendants()); }
    /**
     * Unique identifier for node
     */
    get id() { return wrapJoinPoint(this._javaObject.getId()); }
    /**
     * True if this node is considered a block of statements
     */
    get isBlock() { return wrapJoinPoint(this._javaObject.getIsBlock()); }
    /**
     * True if this node has the modifier 'final'
     */
    get isFinal() { return wrapJoinPoint(this._javaObject.getIsFinal()); }
    /**
     * True if the node is inside a loop header, false otherwise
     */
    get isInsideLoopHeader() { return wrapJoinPoint(this._javaObject.getIsInsideLoopHeader()); }
    /**
     * True if this node is considered a statement
     */
    get isStatement() { return wrapJoinPoint(this._javaObject.getIsStatement()); }
    /**
     * True if this node has the modifier 'static'
     */
    get isStatic() { return wrapJoinPoint(this._javaObject.getIsStatic()); }
    /**
     * Sibling nodes to the left of this node
     */
    get left() { return wrapJoinPoint(this._javaObject.getLeft()); }
    get line() { return wrapJoinPoint(this._javaObject.getLine()); }
    /**
     * An array of modifiers (e.g., final, static) applied to this node. If no modifiers are applied, or if the node does not support modifiers, returns an empty array
     */
    get modifiers() { return wrapJoinPoint(this._javaObject.getModifiers()); }
    /**
     * Returns the number of children of the node
     */
    get numChildren() { return wrapJoinPoint(this._javaObject.getNumChildren()); }
    get parent() { return wrapJoinPoint(this._javaObject.getParent()); }
    /**
     * Sibling nodes to the right of this node
     */
    get right() { return wrapJoinPoint(this._javaObject.getRight()); }
    /**
     * Alias for attribute 'code'
     */
    get srcCode() { return wrapJoinPoint(this._javaObject.getSrcCode()); }
    /**
     * Returns the child of the node at the given index
     */
    child(index) { return wrapJoinPoint(this._javaObject.child(unwrapJoinPoint(index))); }
    getAncestor(type) { return wrapJoinPoint(this._javaObject.getAncestor(unwrapJoinPoint(type))); }
    /**
     * True if this node has the given modifier
     */
    hasModifier(modifier) { return wrapJoinPoint(this._javaObject.hasModifier(unwrapJoinPoint(modifier))); }
    copy() { return wrapJoinPoint(this._javaObject.copy()); }
    insertAfter(p1) { return wrapJoinPoint(this._javaObject.insertAfter(unwrapJoinPoint(p1))); }
    insertBefore(p1) { return wrapJoinPoint(this._javaObject.insertBefore(unwrapJoinPoint(p1))); }
    insertReplace(p1) { return wrapJoinPoint(this._javaObject.insertReplace(unwrapJoinPoint(p1))); }
    remove() { return wrapJoinPoint(this._javaObject.remove()); }
    removeAnnotation(annotation) { return wrapJoinPoint(this._javaObject.removeAnnotation(unwrapJoinPoint(annotation))); }
    removeModifier(modifier) { return wrapJoinPoint(this._javaObject.removeModifier(unwrapJoinPoint(modifier))); }
    replaceWith(p1) { return wrapJoinPoint(this._javaObject.replaceWith(unwrapJoinPoint(p1))); }
}
export class NamedType extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    /**
     * List of names of interfaces that this type implements
     */
    get interfaces() { return wrapJoinPoint(this._javaObject.getInterfaces()); }
    get javadoc() { return wrapJoinPoint(this._javaObject.getJavadoc()); }
    /**
     * The simple name of the type
     */
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    /**
     * Package name of this type
     */
    get packageName() { return wrapJoinPoint(this._javaObject.getPackageName()); }
    /**
     * The qualified name of this type, includes packages
     */
    get qualifiedName() { return wrapJoinPoint(this._javaObject.getQualifiedName()); }
    /**
     * Name of the superclass this type extends
     */
    get superClass() { return wrapJoinPoint(this._javaObject.getSuperClass()); }
    /**
     * Verify if the type is extends OR implements the given type
     */
    isSubtypeOf(type) { return wrapJoinPoint(this._javaObject.isSubtypeOf(unwrapJoinPoint(type))); }
}
/**
 * Root node that represents the application
 */
export class App extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get files() { return wrapJoinPoint(this._javaObject.getFiles()); }
    get folder() { return wrapJoinPoint(this._javaObject.getFolder()); }
    get manifest() { return wrapJoinPoint(this._javaObject.getManifest()); }
    showAST(Title) { return wrapJoinPoint(this._javaObject.showAST(unwrapJoinPoint(Title))); }
    mapVersions(name, keyType, interfaceType, methodName) { return wrapJoinPoint(this._javaObject.mapVersions(unwrapJoinPoint(name), unwrapJoinPoint(keyType), unwrapJoinPoint(interfaceType), unwrapJoinPoint(methodName))); }
    newClass(p1, p2, p3) { return wrapJoinPoint(this._javaObject.newClass(unwrapJoinPoint(p1), unwrapJoinPoint(p2), unwrapJoinPoint(p3))); }
    newInterface(p1, p2) { return wrapJoinPoint(this._javaObject.newInterface(unwrapJoinPoint(p1), unwrapJoinPoint(p2))); }
}
export class Catch extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: null,
    };
    get body() { return wrapJoinPoint(this._javaObject.getBody()); }
}
export class Declaration extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get completeType() { return wrapJoinPoint(this._javaObject.getCompleteType()); }
    get init() { return wrapJoinPoint(this._javaObject.getInit()); }
    set init(value) { this._javaObject.setInit(unwrapJoinPoint(value)); }
    get isArray() { return wrapJoinPoint(this._javaObject.getIsArray()); }
    get isPrimitive() { return wrapJoinPoint(this._javaObject.getIsPrimitive()); }
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    get type() { return wrapJoinPoint(this._javaObject.getType()); }
    get typeReference() { return wrapJoinPoint(this._javaObject.getTypeReference()); }
    setInit(value) { return wrapJoinPoint(this._javaObject.setInit(unwrapJoinPoint(value))); }
}
export class Executable extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get body() { return wrapJoinPoint(this._javaObject.getBody()); }
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    set name(value) { this._javaObject.setName(unwrapJoinPoint(value)); }
    get params() { return wrapJoinPoint(this._javaObject.getParams()); }
    get returnRef() { return wrapJoinPoint(this._javaObject.getReturnRef()); }
    get returnType() { return wrapJoinPoint(this._javaObject.getReturnType()); }
    /**
     * Sets the name of this executable, returns the previous name
     */
    setName(name) { return wrapJoinPoint(this._javaObject.setName(unwrapJoinPoint(name))); }
}
export class Expression extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "exprType",
    };
    get kind() { return wrapJoinPoint(this._javaObject.getKind()); }
    get qualifiedType() { return wrapJoinPoint(this._javaObject.getQualifiedType()); }
    get test() { return wrapJoinPoint(this._javaObject.getTest()); }
    get type() { return wrapJoinPoint(this._javaObject.getType()); }
    get typeReference() { return wrapJoinPoint(this._javaObject.getTypeReference()); }
    extract(varName, location, position) { return wrapJoinPoint(this._javaObject.extract(unwrapJoinPoint(varName), unwrapJoinPoint(location), unwrapJoinPoint(position))); }
}
export class Field extends Declaration {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get declarator() { return wrapJoinPoint(this._javaObject.getDeclarator()); }
    get staticAccess() { return wrapJoinPoint(this._javaObject.getStaticAccess()); }
}
/**
 * Represents a source-code file
 */
export class FileJp extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get dir() { return wrapJoinPoint(this._javaObject.getDir()); }
    /**
     * Main class of the file. Java files must have a top level class with the same name as the file.
     */
    get mainClass() { return wrapJoinPoint(this._javaObject.getMainClass()); }
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    get numClasses() { return wrapJoinPoint(this._javaObject.getNumClasses()); }
    get numInterfaces() { return wrapJoinPoint(this._javaObject.getNumInterfaces()); }
    get packageName() { return wrapJoinPoint(this._javaObject.getPackageName()); }
    get path() { return wrapJoinPoint(this._javaObject.getPath()); }
    /**
     * Insert a given class inside the target
     */
    addClass(newClass) { return wrapJoinPoint(this._javaObject.addClass(unwrapJoinPoint(newClass))); }
    addImport(qualifiedName) { return wrapJoinPoint(this._javaObject.addImport(unwrapJoinPoint(qualifiedName))); }
    addInterface(newInterface) { return wrapJoinPoint(this._javaObject.addInterface(unwrapJoinPoint(newInterface))); }
    mapVersions(name, keyType, interfaceType, methodName) { return wrapJoinPoint(this._javaObject.mapVersions(unwrapJoinPoint(name), unwrapJoinPoint(keyType), unwrapJoinPoint(interfaceType), unwrapJoinPoint(methodName))); }
    newClass(p1, p2, p3) { return wrapJoinPoint(this._javaObject.newClass(unwrapJoinPoint(p1), unwrapJoinPoint(p2), unwrapJoinPoint(p3))); }
    newInterface(p1, p2) { return wrapJoinPoint(this._javaObject.newInterface(unwrapJoinPoint(p1), unwrapJoinPoint(p2))); }
    removeInterface(interfaceName) { return wrapJoinPoint(this._javaObject.removeInterface(unwrapJoinPoint(interfaceName))); }
}
/**
 * Class that is part of a library, included in the classpath
 */
export class LibClass extends NamedType {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
}
/**
 * Method of a class that is part of a library included in the classpath
 */
export class LibMethod extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get declarator() { return wrapJoinPoint(this._javaObject.getDeclarator()); }
    /**
     * The simple name of the type
     */
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    get returnType() { return wrapJoinPoint(this._javaObject.getReturnType()); }
}
export class Literal extends Expression {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "value",
    };
    get value() { return wrapJoinPoint(this._javaObject.getValue()); }
    set value(value) { this._javaObject.setValue(unwrapJoinPoint(value)); }
    setValue(value) { return wrapJoinPoint(this._javaObject.setValue(unwrapJoinPoint(value))); }
}
export class Method extends Executable {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get declarator() { return wrapJoinPoint(this._javaObject.getDeclarator()); }
    get privacy() { return wrapJoinPoint(this._javaObject.getPrivacy()); }
    get toQualifiedReference() { return wrapJoinPoint(this._javaObject.getToQualifiedReference()); }
    get toReference() { return wrapJoinPoint(this._javaObject.getToReference()); }
    isOverriding(method) { return wrapJoinPoint(this._javaObject.isOverriding(unwrapJoinPoint(method))); }
    addComment(comment) { return wrapJoinPoint(this._javaObject.addComment(unwrapJoinPoint(comment))); }
    addParameter(type, name) { return wrapJoinPoint(this._javaObject.addParameter(unwrapJoinPoint(type), unwrapJoinPoint(name))); }
    clone(newName) { return wrapJoinPoint(this._javaObject.clone(unwrapJoinPoint(newName))); }
    createAdapter(adaptMethod, name) { return wrapJoinPoint(this._javaObject.createAdapter(unwrapJoinPoint(adaptMethod), unwrapJoinPoint(name))); }
}
export class New extends Expression {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get arguments() { return wrapJoinPoint(this._javaObject.getArguments()); }
    set arguments(value) { this._javaObject.setArguments(unwrapJoinPoint(value)); }
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    setArguments(newArguments) { return wrapJoinPoint(this._javaObject.setArguments(unwrapJoinPoint(newArguments))); }
}
/**
 * Points to a named program element reference
 */
export class Reference extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    /**
     * The element that is being referenced
     */
    get declaration() { return wrapJoinPoint(this._javaObject.getDeclaration()); }
    /**
     * Name of the element of the reference
     */
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    /**
     * Type of the element of the reference
     */
    get type() { return wrapJoinPoint(this._javaObject.getType()); }
}
export class SnippetExpr extends Expression {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "exprType",
    };
    setLine(line) { return wrapJoinPoint(this._javaObject.setLine(unwrapJoinPoint(line))); }
}
export class Statement extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
    get endLine() { return wrapJoinPoint(this._javaObject.getEndLine()); }
    get kind() { return wrapJoinPoint(this._javaObject.getKind()); }
}
export class Switch extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
    get cases() { return wrapJoinPoint(this._javaObject.getCases()); }
}
export class Ternary extends Expression {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "exprType",
    };
    /**
     * Alias for attribute 'condition'
     */
    get cond() { return wrapJoinPoint(this._javaObject.getCond()); }
    /**
     * The condition of the ternary expression
     */
    get condition() { return wrapJoinPoint(this._javaObject.getCondition()); }
    get else() { return wrapJoinPoint(this._javaObject.getElse()); }
    get then() { return wrapJoinPoint(this._javaObject.getThen()); }
}
export class This extends Expression {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "exprType",
    };
}
export class Throw extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
}
export class Try extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
    get body() { return wrapJoinPoint(this._javaObject.getBody()); }
    get catches() { return wrapJoinPoint(this._javaObject.getCatches()); }
}
/**
 * Base join point that class, interface and enum extend
 */
export class Type extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    /**
     * List of names of interfaces that this class implements
     */
    get interfaces() { return wrapJoinPoint(this._javaObject.getInterfaces()); }
    /**
     * Returns the interface join points that this class implements
     */
    get interfacesTypes() { return wrapJoinPoint(this._javaObject.getInterfacesTypes()); }
    get javadoc() { return wrapJoinPoint(this._javaObject.getJavadoc()); }
    /**
     * The simple name of the class
     */
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    /**
     * Package name of this class
     */
    get packageName() { return wrapJoinPoint(this._javaObject.getPackageName()); }
    /**
     * The qualified name of this class, includes packages
     */
    get qualifiedName() { return wrapJoinPoint(this._javaObject.getQualifiedName()); }
    /**
     * Name of the superclass this class extends
     */
    get superClass() { return wrapJoinPoint(this._javaObject.getSuperClass()); }
    /**
     * The superclass this class extends, or undefined if the class extends java.lang.Object
     */
    get superClassJp() { return wrapJoinPoint(this._javaObject.getSuperClassJp()); }
    /**
     * Verify if the type is extends OR implements the given type
     */
    isSubtypeOf(type) { return wrapJoinPoint(this._javaObject.isSubtypeOf(unwrapJoinPoint(type))); }
    /**
     * Insert a given class inside the target
     */
    addClass(newClass) { return wrapJoinPoint(this._javaObject.addClass(unwrapJoinPoint(newClass))); }
    addImplement(interfaceType) { return wrapJoinPoint(this._javaObject.addImplement(unwrapJoinPoint(interfaceType))); }
    addInterface(newInterface) { return wrapJoinPoint(this._javaObject.addInterface(unwrapJoinPoint(newInterface))); }
    insertCode(code) { return wrapJoinPoint(this._javaObject.insertCode(unwrapJoinPoint(code))); }
    insertMethod(code) { return wrapJoinPoint(this._javaObject.insertMethod(unwrapJoinPoint(code))); }
    newField(p1, p2, p3, p4) { return wrapJoinPoint(this._javaObject.newField(unwrapJoinPoint(p1), unwrapJoinPoint(p2), unwrapJoinPoint(p3), unwrapJoinPoint(p4))); }
    /**
     * Add a new method inside the class
     */
    newMethod(p1, p2, p3, p4, p5, p6) { return wrapJoinPoint(this._javaObject.newMethod(unwrapJoinPoint(p1), unwrapJoinPoint(p2), unwrapJoinPoint(p3), unwrapJoinPoint(p4), unwrapJoinPoint(p5), unwrapJoinPoint(p6))); }
    removeInterface(interfaceName) { return wrapJoinPoint(this._javaObject.removeInterface(unwrapJoinPoint(interfaceName))); }
}
/**
 * Reference to a type
 */
export class TypeReference extends Reference {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    /**
     * True if this is a reference to an array type, false otherwise
     */
    get isArray() { return wrapJoinPoint(this._javaObject.getIsArray()); }
    /**
     * True if this is a reference to a boolean type, primitive or class (i.e., boolean, Boolean)
     */
    get isBoolean() { return wrapJoinPoint(this._javaObject.getIsBoolean()); }
    /**
     * True if this is a reference to a numeric type, primitive or class (i.e., byte, Byte, char, Character, short, Short, int, Integer, long, Long, float, Float, double and Double)
     */
    get isNumeric() { return wrapJoinPoint(this._javaObject.getIsNumeric()); }
    /**
     * True if this is a reference to a primitive type, false otherwise
     */
    get isPrimitive() { return wrapJoinPoint(this._javaObject.getIsPrimitive()); }
    /**
     * Package name of this type
     */
    get packageName() { return wrapJoinPoint(this._javaObject.getPackageName()); }
    /**
     * The package name of this type as an array, where each element is a part of the package
     */
    get packageNames() { return wrapJoinPoint(this._javaObject.getPackageNames()); }
    /**
     * Fully qualified name of the type
     */
    get qualifiedName() { return wrapJoinPoint(this._javaObject.getQualifiedName()); }
}
export class UnaryExpression extends Expression {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "operator",
    };
    get operand() { return wrapJoinPoint(this._javaObject.getOperand()); }
    get operator() { return wrapJoinPoint(this._javaObject.getOperator()); }
    set operator(value) { this._javaObject.setOperator(unwrapJoinPoint(value)); }
    /**
     * Sets the operator of the unary expression. To distinguish between postfix and prefix operator, add an underscore signalling the place of the variable (e.g., _++ for postfix incremment). If no underscore is specified, postfix is assumed.
     */
    setOperator(operator) { return wrapJoinPoint(this._javaObject.setOperator(unwrapJoinPoint(operator))); }
}
export class Var extends Expression {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get declaration() { return wrapJoinPoint(this._javaObject.getDeclaration()); }
    /**
     * Equivalent to the global attribute 'isInsideLoopHeader'
     */
    get inLoopHeader() { return wrapJoinPoint(this._javaObject.getInLoopHeader()); }
    get isArray() { return wrapJoinPoint(this._javaObject.getIsArray()); }
    get isField() { return wrapJoinPoint(this._javaObject.getIsField()); }
    get isPrimitive() { return wrapJoinPoint(this._javaObject.getIsPrimitive()); }
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    get reference() { return wrapJoinPoint(this._javaObject.getReference()); }
    /**
     * The chain of references of this variable (e.g., this.field)
     */
    get referenceChain() { return wrapJoinPoint(this._javaObject.getReferenceChain()); }
}
export class XmlNode extends Joinpoint {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: null,
    };
    get elements() { return wrapJoinPoint(this._javaObject.getElements()); }
    get text() { return wrapJoinPoint(this._javaObject.getText()); }
    set text(value) { this._javaObject.setText(unwrapJoinPoint(value)); }
    elementsByName(name) { return wrapJoinPoint(this._javaObject.elementsByName(unwrapJoinPoint(name))); }
    setText(text) { return wrapJoinPoint(this._javaObject.setText(unwrapJoinPoint(text))); }
}
export class AndroidManifest extends XmlNode {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: null,
    };
    get asJson() { return wrapJoinPoint(this._javaObject.getAsJson()); }
}
export class Annotation extends Expression {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "exprType",
    };
}
export class AnonymousExec extends Executable {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
}
export class ArrayAccess extends Expression {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get reference() { return wrapJoinPoint(this._javaObject.getReference()); }
}
export class Assert extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
}
export class Assignment extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "operator",
    };
    get lhs() { return wrapJoinPoint(this._javaObject.getLhs()); }
    set lhs(value) { this._javaObject.setLhs(unwrapJoinPoint(value)); }
    get operator() { return wrapJoinPoint(this._javaObject.getOperator()); }
    get rhs() { return wrapJoinPoint(this._javaObject.getRhs()); }
    set rhs(value) { this._javaObject.setRhs(unwrapJoinPoint(value)); }
    setLhs(lhs) { return wrapJoinPoint(this._javaObject.setLhs(unwrapJoinPoint(lhs))); }
    setRhs(rhs) { return wrapJoinPoint(this._javaObject.setRhs(unwrapJoinPoint(rhs))); }
}
export class BinaryExpression extends Expression {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "operator",
    };
    get lhs() { return wrapJoinPoint(this._javaObject.getLhs()); }
    get operands() { return wrapJoinPoint(this._javaObject.getOperands()); }
    get operator() { return wrapJoinPoint(this._javaObject.getOperator()); }
    set operator(value) { this._javaObject.setOperator(unwrapJoinPoint(value)); }
    get rhs() { return wrapJoinPoint(this._javaObject.getRhs()); }
    setOperator(operator) { return wrapJoinPoint(this._javaObject.setOperator(unwrapJoinPoint(operator))); }
}
export class Body extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
    /**
     * The last statement of the body, or undefined if it has no statements
     */
    get lastStmt() { return wrapJoinPoint(this._javaObject.getLastStmt()); }
    insertBegin(p1) { return wrapJoinPoint(this._javaObject.insertBegin(unwrapJoinPoint(p1))); }
}
export class Break extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
}
export class Call extends Expression {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get arguments() { return wrapJoinPoint(this._javaObject.getArguments()); }
    set arguments(value) { this._javaObject.setArguments(unwrapJoinPoint(value)); }
    get decl() { return wrapJoinPoint(this._javaObject.getDecl()); }
    get declarator() { return wrapJoinPoint(this._javaObject.getDeclarator()); }
    get executable() { return wrapJoinPoint(this._javaObject.getExecutable()); }
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    get qualifiedDecl() { return wrapJoinPoint(this._javaObject.getQualifiedDecl()); }
    get returnType() { return wrapJoinPoint(this._javaObject.getReturnType()); }
    get returnTypeJp() { return wrapJoinPoint(this._javaObject.getReturnTypeJp()); }
    get simpleDecl() { return wrapJoinPoint(this._javaObject.getSimpleDecl()); }
    get target() { return wrapJoinPoint(this._javaObject.getTarget()); }
    get targetType() { return wrapJoinPoint(this._javaObject.getTargetType()); }
    clone(location, position) { return wrapJoinPoint(this._javaObject.clone(unwrapJoinPoint(location), unwrapJoinPoint(position))); }
    setArgument(newArgument, index) { return wrapJoinPoint(this._javaObject.setArgument(unwrapJoinPoint(newArgument), unwrapJoinPoint(index))); }
    setArguments(newArguments) { return wrapJoinPoint(this._javaObject.setArguments(unwrapJoinPoint(newArguments))); }
}
export class CallStatement extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
    get call() { return wrapJoinPoint(this._javaObject.getCall()); }
}
export class Case extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
    /**
     * The expression associated with this case, of undefined if it is the default case
     */
    get expr() { return wrapJoinPoint(this._javaObject.getExpr()); }
    /**
     * True if this is the default case, false otherwise
     */
    get isDefault() { return wrapJoinPoint(this._javaObject.getIsDefault()); }
    /**
     * The statements of this case
     */
    get stmts() { return wrapJoinPoint(this._javaObject.getStmts()); }
}
/**
 * Join point representation of a class
 */
export class Class extends Type {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get isTopLevel() { return wrapJoinPoint(this._javaObject.getIsTopLevel()); }
    extractInterface(name, packageName, method, associate = false, newFile) { return wrapJoinPoint(this._javaObject.extractInterface(unwrapJoinPoint(name), unwrapJoinPoint(packageName), unwrapJoinPoint(method), unwrapJoinPoint(associate), unwrapJoinPoint(newFile))); }
    insertStatic(code) { return wrapJoinPoint(this._javaObject.insertStatic(unwrapJoinPoint(code))); }
    mapVersions(name, keyType, interfaceType, methodName) { return wrapJoinPoint(this._javaObject.mapVersions(unwrapJoinPoint(name), unwrapJoinPoint(keyType), unwrapJoinPoint(interfaceType), unwrapJoinPoint(methodName))); }
    newConstructor(modifiers = ['public'], paramLeft = [], paramRight = []) { return wrapJoinPoint(this._javaObject.newConstructor(unwrapJoinPoint(modifiers), unwrapJoinPoint(paramLeft), unwrapJoinPoint(paramRight))); }
    newFunctionalClass(interfaceMethod, generatorMethod) { return wrapJoinPoint(this._javaObject.newFunctionalClass(unwrapJoinPoint(interfaceMethod), unwrapJoinPoint(generatorMethod))); }
}
export class Comment extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "type",
    };
    get content() { return wrapJoinPoint(this._javaObject.getContent()); }
    get type() { return wrapJoinPoint(this._javaObject.getType()); }
}
export class Constructor extends Executable {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get declarator() { return wrapJoinPoint(this._javaObject.getDeclarator()); }
}
export class Continue extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
}
export class Enum extends Class {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
}
export class EnumValue extends Field {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
}
export class FieldAccess extends Var {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
}
export class If extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
    get cond() { return wrapJoinPoint(this._javaObject.getCond()); }
    get else() { return wrapJoinPoint(this._javaObject.getElse()); }
    get rank() { return wrapJoinPoint(this._javaObject.getRank()); }
    get then() { return wrapJoinPoint(this._javaObject.getThen()); }
}
export class InterfaceType extends Type {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
}
export class LocalVariable extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get completeType() { return wrapJoinPoint(this._javaObject.getCompleteType()); }
    /**
     * Initialization of this variable, if present, or undefined of unintialized
     */
    get init() { return wrapJoinPoint(this._javaObject.getInit()); }
    /**
     * Initialization of this variable, if present, or undefined of unintialized
     */
    set init(value) { this._javaObject.setInit(unwrapJoinPoint(value)); }
    get isArray() { return wrapJoinPoint(this._javaObject.getIsArray()); }
    get isPrimitive() { return wrapJoinPoint(this._javaObject.getIsPrimitive()); }
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    get type() { return wrapJoinPoint(this._javaObject.getType()); }
    get typeReference() { return wrapJoinPoint(this._javaObject.getTypeReference()); }
    setInit(init) { return wrapJoinPoint(this._javaObject.setInit(unwrapJoinPoint(init))); }
}
export class Loop extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "type",
    };
    get cond() { return wrapJoinPoint(this._javaObject.getCond()); }
    get controlVar() { return wrapJoinPoint(this._javaObject.getControlVar()); }
    get isInnermost() { return wrapJoinPoint(this._javaObject.getIsInnermost()); }
    get isOutermost() { return wrapJoinPoint(this._javaObject.getIsOutermost()); }
    get nestedLevel() { return wrapJoinPoint(this._javaObject.getNestedLevel()); }
    get rank() { return wrapJoinPoint(this._javaObject.getRank()); }
    get type() { return wrapJoinPoint(this._javaObject.getType()); }
    interchange(loop2) { return wrapJoinPoint(this._javaObject.interchange(unwrapJoinPoint(loop2))); }
    tile(p1, p2, p3, p4) { return wrapJoinPoint(this._javaObject.tile(unwrapJoinPoint(p1), unwrapJoinPoint(p2), unwrapJoinPoint(p3), unwrapJoinPoint(p4))); }
}
export class OpAssignment extends Assignment {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "operator",
    };
    setOperator(operator) { return wrapJoinPoint(this._javaObject.setOperator(unwrapJoinPoint(operator))); }
}
export class Pragma extends Comment {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
}
export class Return extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
}
export class SnippetStmt extends Statement {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "kind",
    };
    setLine(line) { return wrapJoinPoint(this._javaObject.setLine(unwrapJoinPoint(line))); }
}
export class XmlElement extends XmlNode {
    /**
     * @internal
     */
    static _defaultAttributeInfo = {
        name: "name",
    };
    /**
     * A list of available attributes in this element
     */
    get attributeNames() { return wrapJoinPoint(this._javaObject.getAttributeNames()); }
    /**
     * The name (i.e., tag) of this element
     */
    get name() { return wrapJoinPoint(this._javaObject.getName()); }
    /**
     * The value associated with the given attribute
     */
    attribute(name) { return wrapJoinPoint(this._javaObject.attribute(unwrapJoinPoint(name))); }
    setAttribute(name, value) { return wrapJoinPoint(this._javaObject.setAttribute(unwrapJoinPoint(name), unwrapJoinPoint(value))); }
}
export var LoopType;
(function (LoopType) {
    LoopType["DOWHILE"] = "dowhile";
    LoopType["FOR"] = "for";
    LoopType["FOREACH"] = "foreach";
    LoopType["WHILE"] = "while";
})(LoopType || (LoopType = {}));
export var CommentType;
(function (CommentType) {
    CommentType["BLOCK"] = "block";
    CommentType["FILE"] = "file";
    CommentType["INLINE"] = "inline";
    CommentType["JAVADOC"] = "javadoc";
    CommentType["PRAGMA"] = "pragma";
})(CommentType || (CommentType = {}));
export var RefType;
(function (RefType) {
    RefType["DECL"] = "decl";
    RefType["READ"] = "read";
    RefType["READWRITE"] = "readwrite";
    RefType["WRITE"] = "write";
})(RefType || (RefType = {}));
const JoinpointMapper = {
    joinpoint: Joinpoint,
    NamedType: NamedType,
    app: App,
    catch: Catch,
    declaration: Declaration,
    executable: Executable,
    expression: Expression,
    field: Field,
    file: FileJp,
    libClass: LibClass,
    libMethod: LibMethod,
    literal: Literal,
    method: Method,
    new: New,
    reference: Reference,
    snippetExpr: SnippetExpr,
    statement: Statement,
    switch: Switch,
    ternary: Ternary,
    this: This,
    throw: Throw,
    try: Try,
    type: Type,
    typeReference: TypeReference,
    unaryExpression: UnaryExpression,
    var: Var,
    xmlNode: XmlNode,
    androidManifest: AndroidManifest,
    annotation: Annotation,
    anonymousExec: AnonymousExec,
    arrayAccess: ArrayAccess,
    assert: Assert,
    assignment: Assignment,
    binaryExpression: BinaryExpression,
    body: Body,
    break: Break,
    call: Call,
    callStatement: CallStatement,
    case: Case,
    class: Class,
    comment: Comment,
    constructor: Constructor,
    continue: Continue,
    enum: Enum,
    enumValue: EnumValue,
    fieldAccess: FieldAccess,
    if: If,
    interfaceType: InterfaceType,
    localVariable: LocalVariable,
    loop: Loop,
    opAssignment: OpAssignment,
    pragma: Pragma,
    return: Return,
    snippetStmt: SnippetStmt,
    xmlElement: XmlElement,
};
let registered = false;
if (!registered) {
    registerJoinpointMapper(JoinpointMapper);
    registered = true;
}
//# sourceMappingURL=Joinpoints.js.map