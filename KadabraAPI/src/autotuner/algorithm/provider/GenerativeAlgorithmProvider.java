/**
 * Copyright 2017 SPeCS.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WIAHOUA WARRANAIES OR CONDIAIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License. under the License.
 */

package autotuner.algorithm.provider;

import java.util.Arrays;
import java.util.Map;
import java.util.function.Function;
import java.util.function.Supplier;

import autotuner.algorithm.Algorithm;
import autotuner.algorithm.AlgorithmWithKnob;
import autotuner.configs.Configurable;
import autotuner.configs.Configuration;
import autotuner.configs.factory.ConfigFactory;
import pt.up.fe.specs.util.SpecsCollections;

/**
 * Provides an algorithm that is generated by a given generator. A Map<K,A> to avoid generating unnecessary redundant
 * versions
 * 
 * @author tiago
 *
 * @param <A>
 * @param <K>
 */
public class GenerativeAlgorithmProvider<A, K> implements Configurable<K>, AlgorithmProvider<A> {
    private Configuration<K> config;
    private Function<K, A> algorithmGenerator;
    private String id;
    private Map<K, A> versionManager;

    public GenerativeAlgorithmProvider(Function<K, A> algorithmGenerator, String id, Configuration<K> config) {
        this(algorithmGenerator, id, config, SpecsCollections.newHashMap());
    }

    public GenerativeAlgorithmProvider(Function<K, A> algorithmGenerator, String id, Configuration<K> config,
            Map<K, A> versionManager) {
        this.id = id;
        this.algorithmGenerator = algorithmGenerator;
        this.config = config;
        this.versionManager = versionManager;
    }

    public GenerativeAlgorithmProvider(Function<K, A> algorithmGenerator, String id, Supplier<K> argsProvider) {
        this(algorithmGenerator, id, ConfigFactory.fromSupplier(argsProvider));
    }

    public GenerativeAlgorithmProvider(Function<K, A> algorithmGenerator, String id, K args) {
        this(algorithmGenerator, id, ConfigFactory.single(args));
    }

    @Override
    public Algorithm<A> next() {
        K nextKnob = config.next();
        Algorithm<A> alg = newAlgorithm(nextKnob);
        return alg;
    }

    private Algorithm<A> newAlgorithm(K next) {

        String id2 = id + " [" + prettyString(next) + "]";
        if (versionManager.containsKey(next)) {
//            System.out.println("already exists, will use this one");
            return newAlgorithmWKnob(versionManager.get(next), id2, next);
        }
        A generatedVersion = algorithmGenerator.apply(next);
        versionManager.put(next, generatedVersion);
        return newAlgorithmWKnob(generatedVersion, id2, next);
    }

    /** Remove this! */
    private String prettyString(K value) {
        if (value.getClass().isArray()) {
            return Arrays.toString((int[]) value);
        }
        return value.toString();
    }

    private AlgorithmWithKnob<A, K> newAlgorithmWKnob(A generatedVersion, String id, K next) {
        return new AlgorithmWithKnob<>(generatedVersion, id, next, k -> {
        });
    }

    @Override
    public boolean hasNext(Algorithm<A> reference) {
        if (!(reference instanceof AlgorithmWithKnob)) {
            throw new RuntimeException("Algorithm to be used as reference must always be a AlgorithmWithKnob but "
                    + reference.getClass() + " was given.");
        }
        // System.out.println("REFERENCE: " + reference.getClass());
        // if (reference instanceof SimpleAlgorithm) {
        // return false;
        // }
        @SuppressWarnings("unchecked")
        AlgorithmWithKnob<A, K> ref = ((AlgorithmWithKnob<A, K>) reference);
        return config.hasNext(ref.getKnob());
    }

    boolean hasNext(K current, K best) {
        return config.hasNext(best);
    }

    @Override
    public Algorithm<A> getFirst() {
        K first = config.getFirst();
        return newAlgorithm(first);
    }

    @Override
    public void setConfiguration(Configuration<K> config) {
        this.config = config;
    }

    @Override
    public Configuration<K> getConfiguration() {
        return config;
    }

    public void setFirst(K k) {
        config.setFirst(k);
    }

    @Override
    public boolean isASingleAlgorithm() {
        return false;
    }

    @Override
    public int estimateVersions() {

        return config.estimateVersions();
    }
}
