///////////////////////////////////////////////////
// This file is generated by build-interfaces.js //
///////////////////////////////////////////////////

/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-duplicate-type-constituents */

import {
  LaraJoinPoint,
  type JoinpointMapperType,
  registerJoinpointMapper,
  wrapJoinPoint,
  unwrapJoinPoint,
} from "@specs-feup/lara/api/LaraJoinPoint.js";

type PrivateMapper = {
  "Joinpoint": typeof Joinpoint,
  "NamedType": typeof NamedType,
  "App": typeof App,
  "Catch": typeof Catch,
  "Declaration": typeof Declaration,
  "Executable": typeof Executable,
  "Expression": typeof Expression,
  "Field": typeof Field,
  "FileJp": typeof FileJp,
  "LibClass": typeof LibClass,
  "LibMethod": typeof LibMethod,
  "Literal": typeof Literal,
  "Method": typeof Method,
  "New": typeof New,
  "Reference": typeof Reference,
  "SnippetExpr": typeof SnippetExpr,
  "Statement": typeof Statement,
  "Switch": typeof Switch,
  "Ternary": typeof Ternary,
  "This": typeof This,
  "Throw": typeof Throw,
  "Try": typeof Try,
  "Type": typeof Type,
  "TypeReference": typeof TypeReference,
  "UnaryExpression": typeof UnaryExpression,
  "Var": typeof Var,
  "XmlNode": typeof XmlNode,
  "AndroidManifest": typeof AndroidManifest,
  "Annotation": typeof Annotation,
  "AnonymousExec": typeof AnonymousExec,
  "ArrayAccess": typeof ArrayAccess,
  "Assert": typeof Assert,
  "Assignment": typeof Assignment,
  "BinaryExpression": typeof BinaryExpression,
  "Body": typeof Body,
  "Break": typeof Break,
  "Call": typeof Call,
  "CallStatement": typeof CallStatement,
  "Case": typeof Case,
  "Class": typeof Class,
  "Comment": typeof Comment,
  "Constructor": typeof Constructor,
  "Continue": typeof Continue,
  "Enum": typeof Enum,
  "EnumValue": typeof EnumValue,
  "FieldAccess": typeof FieldAccess,
  "If": typeof If,
  "InterfaceType": typeof InterfaceType,
  "LocalVariable": typeof LocalVariable,
  "Loop": typeof Loop,
  "OpAssignment": typeof OpAssignment,
  "Pragma": typeof Pragma,
  "Return": typeof Return,
  "SnippetStmt": typeof SnippetStmt,
  "XmlElement": typeof XmlElement,
};

type DefaultAttributeMap = {
  NamedType: "name",
  App: "name",
  Declaration: "name",
  Executable: "name",
  Expression: "exprType",
  Field: "name",
  FileJp: "name",
  LibClass: "name",
  LibMethod: "name",
  Literal: "value",
  Method: "name",
  New: "name",
  Reference: "name",
  SnippetExpr: "exprType",
  Statement: "kind",
  Switch: "kind",
  Ternary: "exprType",
  This: "exprType",
  Throw: "kind",
  Try: "kind",
  Type: "name",
  TypeReference: "name",
  UnaryExpression: "operator",
  Var: "name",
  Annotation: "exprType",
  AnonymousExec: "name",
  ArrayAccess: "name",
  Assert: "kind",
  Assignment: "operator",
  BinaryExpression: "operator",
  Body: "kind",
  Break: "kind",
  Call: "name",
  CallStatement: "kind",
  Case: "kind",
  Class: "name",
  Comment: "type",
  Constructor: "name",
  Continue: "kind",
  Enum: "name",
  EnumValue: "name",
  FieldAccess: "name",
  If: "kind",
  InterfaceType: "name",
  LocalVariable: "name",
  Loop: "type",
  OpAssignment: "operator",
  Pragma: "name",
  Return: "kind",
  SnippetStmt: "kind",
  XmlElement: "name",
}

export class Joinpoint extends LaraJoinPoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  /**
   * An array of the annotations of this node
   */
  get annotations(): Annotation[] { return wrapJoinPoint(this._javaObject.getAnnotations()) }
  /**
   * A string representation of the AST corresponding to this node
   */
  get ast(): string { return wrapJoinPoint(this._javaObject.getAst()) }
  /**
   * Alias of attribute 'parent'
   */
  get astParent(): Joinpoint { return wrapJoinPoint(this._javaObject.getAstParent()) }
  /**
   * Returns an array with the children of the node
   */
  get children(): Joinpoint[] { return wrapJoinPoint(this._javaObject.getChildren()) }
  /**
   * The source code corresponding to this join point
   */
  get code(): string { return wrapJoinPoint(this._javaObject.getCode()) }
  get descendants(): Joinpoint[] { return wrapJoinPoint(this._javaObject.getDescendants()) }
  /**
   * Unique identifier for node
   */
  get id(): string { return wrapJoinPoint(this._javaObject.getId()) }
  /**
   * True if this node is considered a block of statements
   */
  get isBlock(): boolean { return wrapJoinPoint(this._javaObject.getIsBlock()) }
  /**
   * True if this node has the modifier 'final'
   */
  get isFinal(): boolean { return wrapJoinPoint(this._javaObject.getIsFinal()) }
  /**
   * True if the node is inside a loop header, false otherwise
   */
  get isInsideLoopHeader(): boolean { return wrapJoinPoint(this._javaObject.getIsInsideLoopHeader()) }
  /**
   * True if this node is considered a statement
   */
  get isStatement(): boolean { return wrapJoinPoint(this._javaObject.getIsStatement()) }
  /**
   * True if this node has the modifier 'static'
   */
  get isStatic(): boolean { return wrapJoinPoint(this._javaObject.getIsStatic()) }
  /**
   * Sibling nodes to the left of this node
   */
  get left(): Joinpoint[] { return wrapJoinPoint(this._javaObject.getLeft()) }
  get line(): number { return wrapJoinPoint(this._javaObject.getLine()) }
  /**
   * An array of modifiers (e.g., final, static) applied to this node. If no modifiers are applied, or if the node does not support modifiers, returns an empty array
   */
  get modifiers(): string[] { return wrapJoinPoint(this._javaObject.getModifiers()) }
  /**
   * Returns the number of children of the node
   */
  get numChildren(): number { return wrapJoinPoint(this._javaObject.getNumChildren()) }
  get parent(): Joinpoint { return wrapJoinPoint(this._javaObject.getParent()) }
  /**
   * Sibling nodes to the right of this node
   */
  get right(): Joinpoint[] { return wrapJoinPoint(this._javaObject.getRight()) }
  /**
   * Alias for attribute 'code'
   */
  get srcCode(): string { return wrapJoinPoint(this._javaObject.getSrcCode()) }
  /**
   * Returns the child of the node at the given index
   */
  child(index: number): Joinpoint { return wrapJoinPoint(this._javaObject.child(unwrapJoinPoint(index))); }
  getAncestor(type: string): Joinpoint { return wrapJoinPoint(this._javaObject.getAncestor(unwrapJoinPoint(type))); }
  /**
   * True if this node has the given modifier
   */
  hasModifier(modifier: string): boolean { return wrapJoinPoint(this._javaObject.hasModifier(unwrapJoinPoint(modifier))); }
  copy(): Joinpoint { return wrapJoinPoint(this._javaObject.copy()); }
  insertAfter(node: Joinpoint): Joinpoint;
  insertAfter(code: string): Joinpoint;
  insertAfter(p1: Joinpoint | string): Joinpoint { return wrapJoinPoint(this._javaObject.insertAfter(unwrapJoinPoint(p1))); }
  insertBefore(node: Joinpoint): Joinpoint;
  insertBefore(code: string): Joinpoint;
  insertBefore(p1: Joinpoint | string): Joinpoint { return wrapJoinPoint(this._javaObject.insertBefore(unwrapJoinPoint(p1))); }
  insertReplace(jp: Joinpoint): Joinpoint;
  insertReplace(code: string): Joinpoint;
  insertReplace(p1: Joinpoint | string): Joinpoint { return wrapJoinPoint(this._javaObject.insertReplace(unwrapJoinPoint(p1))); }
  remove(): void { return wrapJoinPoint(this._javaObject.remove()); }
  removeAnnotation(annotation: Annotation): void { return wrapJoinPoint(this._javaObject.removeAnnotation(unwrapJoinPoint(annotation))); }
  removeModifier(modifier: string): void { return wrapJoinPoint(this._javaObject.removeModifier(unwrapJoinPoint(modifier))); }
  replaceWith(jp: Joinpoint): Joinpoint;
  replaceWith(code: string): Joinpoint;
  replaceWith(p1: Joinpoint | string): Joinpoint { return wrapJoinPoint(this._javaObject.replaceWith(unwrapJoinPoint(p1))); }
}

export class NamedType extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  /**
   * List of names of interfaces that this type implements
   */
  get interfaces(): string[] { return wrapJoinPoint(this._javaObject.getInterfaces()) }
  get javadoc(): string { return wrapJoinPoint(this._javaObject.getJavadoc()) }
  /**
   * The simple name of the type
   */
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  /**
   * Package name of this type
   */
  get packageName(): string { return wrapJoinPoint(this._javaObject.getPackageName()) }
  /**
   * The qualified name of this type, includes packages
   */
  get qualifiedName(): string { return wrapJoinPoint(this._javaObject.getQualifiedName()) }
  /**
   * Name of the superclass this type extends
   */
  get superClass(): string { return wrapJoinPoint(this._javaObject.getSuperClass()) }
  /**
   * Verify if the type is extends OR implements the given type
   */
  isSubtypeOf(type: string): boolean { return wrapJoinPoint(this._javaObject.isSubtypeOf(unwrapJoinPoint(type))); }
}

  /**
   * Root node that represents the application
   */
export class App extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get files(): FileJp[] { return wrapJoinPoint(this._javaObject.getFiles()) }
  get folder(): string { return wrapJoinPoint(this._javaObject.getFolder()) }
  get manifest(): AndroidManifest { return wrapJoinPoint(this._javaObject.getManifest()) }
  showAST(Title: string): string { return wrapJoinPoint(this._javaObject.showAST(unwrapJoinPoint(Title))); }
  mapVersions(name: string, keyType: string, interfaceType: InterfaceType, methodName: string): Class { return wrapJoinPoint(this._javaObject.mapVersions(unwrapJoinPoint(name), unwrapJoinPoint(keyType), unwrapJoinPoint(interfaceType), unwrapJoinPoint(methodName))); }
  newClass(name: string, extend: string, implement: string[] = []): Class;
  newClass(name: string): Class;
  newClass(p1: string, p2?: string, p3?: string[]): Class { return wrapJoinPoint(this._javaObject.newClass(unwrapJoinPoint(p1), unwrapJoinPoint(p2), unwrapJoinPoint(p3))); }
  newInterface(name: string, extend: string[]): InterfaceType;
  newInterface(name: string): InterfaceType;
  newInterface(p1: string, p2?: string[]): InterfaceType { return wrapJoinPoint(this._javaObject.newInterface(unwrapJoinPoint(p1), unwrapJoinPoint(p2))); }
}

export class Catch extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get body(): Body { return wrapJoinPoint(this._javaObject.getBody()) }
}

export class Declaration extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get completeType(): string { return wrapJoinPoint(this._javaObject.getCompleteType()) }
  get init(): Expression { return wrapJoinPoint(this._javaObject.getInit()) }
  set init(value: Expression) { this._javaObject.setInit(unwrapJoinPoint(value)); }
  get isArray(): boolean { return wrapJoinPoint(this._javaObject.getIsArray()) }
  get isPrimitive(): boolean { return wrapJoinPoint(this._javaObject.getIsPrimitive()) }
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  get type(): string { return wrapJoinPoint(this._javaObject.getType()) }
  get typeReference(): TypeReference { return wrapJoinPoint(this._javaObject.getTypeReference()) }
  setInit(value: Expression): void { return wrapJoinPoint(this._javaObject.setInit(unwrapJoinPoint(value))); }
}

export class Executable extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get body(): Body { return wrapJoinPoint(this._javaObject.getBody()) }
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  set name(value: string) { this._javaObject.setName(unwrapJoinPoint(value)); }
  get params(): Declaration[] { return wrapJoinPoint(this._javaObject.getParams()) }
  get returnRef(): TypeReference { return wrapJoinPoint(this._javaObject.getReturnRef()) }
  get returnType(): string { return wrapJoinPoint(this._javaObject.getReturnType()) }
  /**
   * Sets the name of this executable, returns the previous name
   */
  setName(name: string): string { return wrapJoinPoint(this._javaObject.setName(unwrapJoinPoint(name))); }
}

export class Expression extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "exprType",
  };
  get kind(): string { return wrapJoinPoint(this._javaObject.getKind()) }
  get qualifiedType(): string { return wrapJoinPoint(this._javaObject.getQualifiedType()) }
  get test(): number { return wrapJoinPoint(this._javaObject.getTest()) }
  get type(): string { return wrapJoinPoint(this._javaObject.getType()) }
  get typeReference(): TypeReference { return wrapJoinPoint(this._javaObject.getTypeReference()) }
  extract(varName: string, location?: Statement, position: string): void { return wrapJoinPoint(this._javaObject.extract(unwrapJoinPoint(varName), unwrapJoinPoint(location), unwrapJoinPoint(position))); }
}

export class Field extends Declaration {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get declarator(): string { return wrapJoinPoint(this._javaObject.getDeclarator()) }
  get staticAccess(): string { return wrapJoinPoint(this._javaObject.getStaticAccess()) }
}

  /**
   * Represents a source-code file
   */
export class FileJp extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get dir(): string { return wrapJoinPoint(this._javaObject.getDir()) }
  /**
   * Main class of the file. Java files must have a top level class with the same name as the file.
   */
  get mainClass(): Type { return wrapJoinPoint(this._javaObject.getMainClass()) }
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  get numClasses(): number { return wrapJoinPoint(this._javaObject.getNumClasses()) }
  get numInterfaces(): number { return wrapJoinPoint(this._javaObject.getNumInterfaces()) }
  get packageName(): string { return wrapJoinPoint(this._javaObject.getPackageName()) }
  get path(): string { return wrapJoinPoint(this._javaObject.getPath()) }
  /**
   * Insert a given class inside the target
   */
  addClass(newClass: Class): void { return wrapJoinPoint(this._javaObject.addClass(unwrapJoinPoint(newClass))); }
  addImport(qualifiedName: string): void { return wrapJoinPoint(this._javaObject.addImport(unwrapJoinPoint(qualifiedName))); }
  addInterface(newInterface: InterfaceType): void { return wrapJoinPoint(this._javaObject.addInterface(unwrapJoinPoint(newInterface))); }
  mapVersions(name: string, keyType: string, interfaceType: InterfaceType, methodName: string): Class { return wrapJoinPoint(this._javaObject.mapVersions(unwrapJoinPoint(name), unwrapJoinPoint(keyType), unwrapJoinPoint(interfaceType), unwrapJoinPoint(methodName))); }
  newClass(name: string, extend: string, implement: string[] = []): Class;
  newClass(name: string): Class;
  newClass(p1: string, p2?: string, p3?: string[]): Class { return wrapJoinPoint(this._javaObject.newClass(unwrapJoinPoint(p1), unwrapJoinPoint(p2), unwrapJoinPoint(p3))); }
  newInterface(name: string, extend: string[]): InterfaceType;
  newInterface(name: string): InterfaceType;
  newInterface(p1: string, p2?: string[]): InterfaceType { return wrapJoinPoint(this._javaObject.newInterface(unwrapJoinPoint(p1), unwrapJoinPoint(p2))); }
  removeInterface(interfaceName: string): InterfaceType { return wrapJoinPoint(this._javaObject.removeInterface(unwrapJoinPoint(interfaceName))); }
}

  /**
   * Class that is part of a library, included in the classpath
   */
export class LibClass extends NamedType {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
}

  /**
   * Method of a class that is part of a library included in the classpath
   */
export class LibMethod extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get declarator(): NamedType { return wrapJoinPoint(this._javaObject.getDeclarator()) }
  /**
   * The simple name of the type
   */
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  get returnType(): string { return wrapJoinPoint(this._javaObject.getReturnType()) }
}

export class Literal extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "value",
  };
  get value(): string { return wrapJoinPoint(this._javaObject.getValue()) }
  set value(value: string) { this._javaObject.setValue(unwrapJoinPoint(value)); }
  setValue(value: string): void { return wrapJoinPoint(this._javaObject.setValue(unwrapJoinPoint(value))); }
}

export class Method extends Executable {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get declarator(): string { return wrapJoinPoint(this._javaObject.getDeclarator()) }
  get privacy(): string { return wrapJoinPoint(this._javaObject.getPrivacy()) }
  get toQualifiedReference(): string { return wrapJoinPoint(this._javaObject.getToQualifiedReference()) }
  get toReference(): string { return wrapJoinPoint(this._javaObject.getToReference()) }
  isOverriding(method: Method): boolean { return wrapJoinPoint(this._javaObject.isOverriding(unwrapJoinPoint(method))); }
  addComment(comment: string): void { return wrapJoinPoint(this._javaObject.addComment(unwrapJoinPoint(comment))); }
  addParameter(type: string, name: string): void { return wrapJoinPoint(this._javaObject.addParameter(unwrapJoinPoint(type), unwrapJoinPoint(name))); }
  clone(newName: string): Method { return wrapJoinPoint(this._javaObject.clone(unwrapJoinPoint(newName))); }
  createAdapter(adaptMethod: Method, name: string): Class { return wrapJoinPoint(this._javaObject.createAdapter(unwrapJoinPoint(adaptMethod), unwrapJoinPoint(name))); }
}

export class New extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get arguments(): Expression[] { return wrapJoinPoint(this._javaObject.getArguments()) }
  set arguments(value: Expression[]) { this._javaObject.setArguments(unwrapJoinPoint(value)); }
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  setArguments(newArguments: Expression[]): void { return wrapJoinPoint(this._javaObject.setArguments(unwrapJoinPoint(newArguments))); }
}

  /**
   * Points to a named program element reference
   */
export class Reference extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  /**
   * The element that is being referenced
   */
  get declaration(): Joinpoint { return wrapJoinPoint(this._javaObject.getDeclaration()) }
  /**
   * Name of the element of the reference
   */
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  /**
   * Type of the element of the reference
   */
  get type(): string { return wrapJoinPoint(this._javaObject.getType()) }
}

export class SnippetExpr extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "exprType",
  };
  setLine(line: number): void { return wrapJoinPoint(this._javaObject.setLine(unwrapJoinPoint(line))); }
}

export class Statement extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
  get endLine(): number { return wrapJoinPoint(this._javaObject.getEndLine()) }
  get kind(): string { return wrapJoinPoint(this._javaObject.getKind()) }
}

export class Switch extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
  get cases(): Case[] { return wrapJoinPoint(this._javaObject.getCases()) }
}

export class Ternary extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "exprType",
  };
  /**
   * Alias for attribute 'condition'
   */
  get cond(): Expression { return wrapJoinPoint(this._javaObject.getCond()) }
  /**
   * The condition of the ternary expression
   */
  get condition(): Expression { return wrapJoinPoint(this._javaObject.getCondition()) }
  get else(): Expression { return wrapJoinPoint(this._javaObject.getElse()) }
  get then(): Expression { return wrapJoinPoint(this._javaObject.getThen()) }
}

export class This extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "exprType",
  };
}

export class Throw extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
}

export class Try extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
  get body(): Body { return wrapJoinPoint(this._javaObject.getBody()) }
  get catches(): Catch[] { return wrapJoinPoint(this._javaObject.getCatches()) }
}

  /**
   * Base join point that class, interface and enum extend
   */
export class Type extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  /**
   * List of names of interfaces that this class implements
   */
  get interfaces(): string[] { return wrapJoinPoint(this._javaObject.getInterfaces()) }
  /**
   * Returns the interface join points that this class implements
   */
  get interfacesTypes(): InterfaceType[] { return wrapJoinPoint(this._javaObject.getInterfacesTypes()) }
  get javadoc(): string { return wrapJoinPoint(this._javaObject.getJavadoc()) }
  /**
   * The simple name of the class
   */
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  /**
   * Package name of this class
   */
  get packageName(): string { return wrapJoinPoint(this._javaObject.getPackageName()) }
  /**
   * The qualified name of this class, includes packages
   */
  get qualifiedName(): string { return wrapJoinPoint(this._javaObject.getQualifiedName()) }
  /**
   * Name of the superclass this class extends
   */
  get superClass(): string { return wrapJoinPoint(this._javaObject.getSuperClass()) }
  /**
   * The superclass this class extends, or undefined if the class extends java.lang.Object
   */
  get superClassJp(): TypeReference { return wrapJoinPoint(this._javaObject.getSuperClassJp()) }
  /**
   * Verify if the type is extends OR implements the given type
   */
  isSubtypeOf(type: string): boolean { return wrapJoinPoint(this._javaObject.isSubtypeOf(unwrapJoinPoint(type))); }
  /**
   * Insert a given class inside the target
   */
  addClass(newClass: Class): void { return wrapJoinPoint(this._javaObject.addClass(unwrapJoinPoint(newClass))); }
  addImplement(interfaceType: InterfaceType): void { return wrapJoinPoint(this._javaObject.addImplement(unwrapJoinPoint(interfaceType))); }
  addInterface(newInterface: InterfaceType): void { return wrapJoinPoint(this._javaObject.addInterface(unwrapJoinPoint(newInterface))); }
  insertCode(code: string): void { return wrapJoinPoint(this._javaObject.insertCode(unwrapJoinPoint(code))); }
  insertMethod(code: string): void { return wrapJoinPoint(this._javaObject.insertMethod(unwrapJoinPoint(code))); }
  newField(modifiers: string[], type: string, name: string, defaultValue?: string): Field;
  newField(modifiers: string[], type: string, name: string): Field;
  newField(p1: string[], p2: string, p3: string, p4?: string): Field { return wrapJoinPoint(this._javaObject.newField(unwrapJoinPoint(p1), unwrapJoinPoint(p2), unwrapJoinPoint(p3), unwrapJoinPoint(p4))); }
  /**
   * Add a new method inside the class
   */
  newMethod(modifiers: string[], returnType: string, name: string, paramLeft: string[] = [], paramRight: string[] = [], code: string): Method;
  /**
   * Overload which accepts 4 parameters (code is empty string)
   */
  newMethod(modifiers: string[] = ['public'], returnType: string, name: string, paramLeft: string[] = [], paramRight: string[] = []): Method;
  /**
   * Add a new method inside the class
   */
  newMethod(p1: string[], p2: string, p3: string, p4?: string[], p5?: string[], p6?: string): Method { return wrapJoinPoint(this._javaObject.newMethod(unwrapJoinPoint(p1), unwrapJoinPoint(p2), unwrapJoinPoint(p3), unwrapJoinPoint(p4), unwrapJoinPoint(p5), unwrapJoinPoint(p6))); }
  removeInterface(interfaceName: string): InterfaceType { return wrapJoinPoint(this._javaObject.removeInterface(unwrapJoinPoint(interfaceName))); }
}

  /**
   * Reference to a type
   */
export class TypeReference extends Reference {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  /**
   * True if this is a reference to an array type, false otherwise
   */
  get isArray(): boolean { return wrapJoinPoint(this._javaObject.getIsArray()) }
  /**
   * True if this is a reference to a boolean type, primitive or class (i.e., boolean, Boolean)
   */
  get isBoolean(): boolean { return wrapJoinPoint(this._javaObject.getIsBoolean()) }
  /**
   * True if this is a reference to a numeric type, primitive or class (i.e., byte, Byte, char, Character, short, Short, int, Integer, long, Long, float, Float, double and Double)
   */
  get isNumeric(): boolean { return wrapJoinPoint(this._javaObject.getIsNumeric()) }
  /**
   * True if this is a reference to a primitive type, false otherwise
   */
  get isPrimitive(): boolean { return wrapJoinPoint(this._javaObject.getIsPrimitive()) }
  /**
   * Package name of this type
   */
  get packageName(): string { return wrapJoinPoint(this._javaObject.getPackageName()) }
  /**
   * The package name of this type as an array, where each element is a part of the package
   */
  get packageNames(): string[] { return wrapJoinPoint(this._javaObject.getPackageNames()) }
  /**
   * Fully qualified name of the type
   */
  get qualifiedName(): string { return wrapJoinPoint(this._javaObject.getQualifiedName()) }
}

export class UnaryExpression extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "operator",
  };
  get operand(): Expression { return wrapJoinPoint(this._javaObject.getOperand()) }
  get operator(): string { return wrapJoinPoint(this._javaObject.getOperator()) }
  set operator(value: string) { this._javaObject.setOperator(unwrapJoinPoint(value)); }
  /**
   * Sets the operator of the unary expression. To distinguish between postfix and prefix operator, add an underscore signalling the place of the variable (e.g., _++ for postfix incremment). If no underscore is specified, postfix is assumed.
   */
  setOperator(operator: string): void { return wrapJoinPoint(this._javaObject.setOperator(unwrapJoinPoint(operator))); }
}

export class Var extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get declaration(): Joinpoint { return wrapJoinPoint(this._javaObject.getDeclaration()) }
  /**
   * Equivalent to the global attribute 'isInsideLoopHeader'
   */
  get inLoopHeader(): boolean { return wrapJoinPoint(this._javaObject.getInLoopHeader()) }
  get isArray(): boolean { return wrapJoinPoint(this._javaObject.getIsArray()) }
  get isField(): boolean { return wrapJoinPoint(this._javaObject.getIsField()) }
  get isPrimitive(): boolean { return wrapJoinPoint(this._javaObject.getIsPrimitive()) }
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  get reference(): RefType { return wrapJoinPoint(this._javaObject.getReference()) }
  /**
   * The chain of references of this variable (e.g., this.field)
   */
  get referenceChain(): Joinpoint[] { return wrapJoinPoint(this._javaObject.getReferenceChain()) }
}

export class XmlNode extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get elements(): XmlElement[] { return wrapJoinPoint(this._javaObject.getElements()) }
  get text(): string { return wrapJoinPoint(this._javaObject.getText()) }
  set text(value: string) { this._javaObject.setText(unwrapJoinPoint(value)); }
  elementsByName(name: string): XmlElement[] { return wrapJoinPoint(this._javaObject.elementsByName(unwrapJoinPoint(name))); }
  setText(text: string): string { return wrapJoinPoint(this._javaObject.setText(unwrapJoinPoint(text))); }
}

export class AndroidManifest extends XmlNode {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get asJson(): object { return wrapJoinPoint(this._javaObject.getAsJson()) }
}

export class Annotation extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "exprType",
  };
}

export class AnonymousExec extends Executable {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
}

export class ArrayAccess extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get reference(): RefType { return wrapJoinPoint(this._javaObject.getReference()) }
}

export class Assert extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
}

export class Assignment extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "operator",
  };
  get lhs(): Expression { return wrapJoinPoint(this._javaObject.getLhs()) }
  set lhs(value: Expression) { this._javaObject.setLhs(unwrapJoinPoint(value)); }
  get operator(): string { return wrapJoinPoint(this._javaObject.getOperator()) }
  get rhs(): Expression { return wrapJoinPoint(this._javaObject.getRhs()) }
  set rhs(value: Expression) { this._javaObject.setRhs(unwrapJoinPoint(value)); }
  setLhs(lhs: Expression): void { return wrapJoinPoint(this._javaObject.setLhs(unwrapJoinPoint(lhs))); }
  setRhs(rhs: Expression): void { return wrapJoinPoint(this._javaObject.setRhs(unwrapJoinPoint(rhs))); }
}

export class BinaryExpression extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "operator",
  };
  get lhs(): Expression { return wrapJoinPoint(this._javaObject.getLhs()) }
  get operands(): Expression[] { return wrapJoinPoint(this._javaObject.getOperands()) }
  get operator(): string { return wrapJoinPoint(this._javaObject.getOperator()) }
  set operator(value: string) { this._javaObject.setOperator(unwrapJoinPoint(value)); }
  get rhs(): Expression { return wrapJoinPoint(this._javaObject.getRhs()) }
  setOperator(operator: string): void { return wrapJoinPoint(this._javaObject.setOperator(unwrapJoinPoint(operator))); }
}

export class Body extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
  /**
   * The last statement of the body, or undefined if it has no statements
   */
  get lastStmt(): Statement { return wrapJoinPoint(this._javaObject.getLastStmt()) }
  insertBegin(code: string): void;
  insertBegin(statement: Statement): void;
  insertBegin(p1: string | Statement): void { return wrapJoinPoint(this._javaObject.insertBegin(unwrapJoinPoint(p1))); }
}

export class Break extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
}

export class Call extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get arguments(): Expression[] { return wrapJoinPoint(this._javaObject.getArguments()) }
  set arguments(value: Expression[]) { this._javaObject.setArguments(unwrapJoinPoint(value)); }
  get decl(): Method { return wrapJoinPoint(this._javaObject.getDecl()) }
  get declarator(): string { return wrapJoinPoint(this._javaObject.getDeclarator()) }
  get executable(): string { return wrapJoinPoint(this._javaObject.getExecutable()) }
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  get qualifiedDecl(): string { return wrapJoinPoint(this._javaObject.getQualifiedDecl()) }
  get returnType(): string { return wrapJoinPoint(this._javaObject.getReturnType()) }
  get returnTypeJp(): TypeReference { return wrapJoinPoint(this._javaObject.getReturnTypeJp()) }
  get simpleDecl(): string { return wrapJoinPoint(this._javaObject.getSimpleDecl()) }
  get target(): string { return wrapJoinPoint(this._javaObject.getTarget()) }
  get targetType(): Type { return wrapJoinPoint(this._javaObject.getTargetType()) }
  clone(location: Statement, position: string): Call { return wrapJoinPoint(this._javaObject.clone(unwrapJoinPoint(location), unwrapJoinPoint(position))); }
  setArgument(newArgument: Expression, index: number): void { return wrapJoinPoint(this._javaObject.setArgument(unwrapJoinPoint(newArgument), unwrapJoinPoint(index))); }
  setArguments(newArguments: Expression[]): void { return wrapJoinPoint(this._javaObject.setArguments(unwrapJoinPoint(newArguments))); }
}

export class CallStatement extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
  get call(): Call { return wrapJoinPoint(this._javaObject.getCall()) }
}

export class Case extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
  /**
   * The expression associated with this case, of undefined if it is the default case
   */
  get expr(): Expression { return wrapJoinPoint(this._javaObject.getExpr()) }
  /**
   * True if this is the default case, false otherwise
   */
  get isDefault(): boolean { return wrapJoinPoint(this._javaObject.getIsDefault()) }
  /**
   * The statements of this case
   */
  get stmts(): Statement[] { return wrapJoinPoint(this._javaObject.getStmts()) }
}

  /**
   * Join point representation of a class
   */
export class Class extends Type {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get isTopLevel(): boolean { return wrapJoinPoint(this._javaObject.getIsTopLevel()) }
  extractInterface(name: string, package: string, method?: Method, associate: boolean = false, newFile: boolean): InterfaceType { return wrapJoinPoint(this._javaObject.extractInterface(unwrapJoinPoint(name), unwrapJoinPoint(package), unwrapJoinPoint(method), unwrapJoinPoint(associate), unwrapJoinPoint(newFile))); }
  insertStatic(code: string): void { return wrapJoinPoint(this._javaObject.insertStatic(unwrapJoinPoint(code))); }
  mapVersions(name: string, keyType: string, interfaceType: InterfaceType, methodName: string): Class { return wrapJoinPoint(this._javaObject.mapVersions(unwrapJoinPoint(name), unwrapJoinPoint(keyType), unwrapJoinPoint(interfaceType), unwrapJoinPoint(methodName))); }
  newConstructor(modifiers: string[] = ['public'], paramLeft: string[] = [], paramRight: string[] = []): Constructor { return wrapJoinPoint(this._javaObject.newConstructor(unwrapJoinPoint(modifiers), unwrapJoinPoint(paramLeft), unwrapJoinPoint(paramRight))); }
  newFunctionalClass(interfaceMethod: Method, generatorMethod: Method): Method { return wrapJoinPoint(this._javaObject.newFunctionalClass(unwrapJoinPoint(interfaceMethod), unwrapJoinPoint(generatorMethod))); }
}

export class Comment extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "type",
  };
  get content(): string { return wrapJoinPoint(this._javaObject.getContent()) }
  get type(): CommentType { return wrapJoinPoint(this._javaObject.getType()) }
}

export class Constructor extends Executable {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get declarator(): string { return wrapJoinPoint(this._javaObject.getDeclarator()) }
}

export class Continue extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
}

export class Enum extends Class {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
}

export class EnumValue extends Field {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
}

export class FieldAccess extends Var {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
}

export class If extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
  get cond(): Expression { return wrapJoinPoint(this._javaObject.getCond()) }
  get else(): Body { return wrapJoinPoint(this._javaObject.getElse()) }
  get rank(): string { return wrapJoinPoint(this._javaObject.getRank()) }
  get then(): Body { return wrapJoinPoint(this._javaObject.getThen()) }
}

export class InterfaceType extends Type {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
}

export class LocalVariable extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get completeType(): string { return wrapJoinPoint(this._javaObject.getCompleteType()) }
  /**
   * Initialization of this variable, if present, or undefined of unintialized
   */
  get init(): Expression { return wrapJoinPoint(this._javaObject.getInit()) }
  /**
   * Initialization of this variable, if present, or undefined of unintialized
   */
  set init(value: Expression) { this._javaObject.setInit(unwrapJoinPoint(value)); }
  get isArray(): boolean { return wrapJoinPoint(this._javaObject.getIsArray()) }
  get isPrimitive(): boolean { return wrapJoinPoint(this._javaObject.getIsPrimitive()) }
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  get type(): string { return wrapJoinPoint(this._javaObject.getType()) }
  get typeReference(): TypeReference { return wrapJoinPoint(this._javaObject.getTypeReference()) }
  setInit(init: Expression): void { return wrapJoinPoint(this._javaObject.setInit(unwrapJoinPoint(init))); }
}

export class Loop extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "type",
  };
  get cond(): Expression { return wrapJoinPoint(this._javaObject.getCond()) }
  get controlVar(): string { return wrapJoinPoint(this._javaObject.getControlVar()) }
  get isInnermost(): boolean { return wrapJoinPoint(this._javaObject.getIsInnermost()) }
  get isOutermost(): boolean { return wrapJoinPoint(this._javaObject.getIsOutermost()) }
  get nestedLevel(): number { return wrapJoinPoint(this._javaObject.getNestedLevel()) }
  get rank(): string { return wrapJoinPoint(this._javaObject.getRank()) }
  get type(): LoopType { return wrapJoinPoint(this._javaObject.getType()) }
  interchange(loop2: Loop): void { return wrapJoinPoint(this._javaObject.interchange(unwrapJoinPoint(loop2))); }
  tile(tileName: string, block: string, unique: boolean, around?: Joinpoint): Field;
  tile(block: number): void;
  tile(p1: string | number, p2?: string, p3?: boolean, p4?: Joinpoint): Field | void { return wrapJoinPoint(this._javaObject.tile(unwrapJoinPoint(p1), unwrapJoinPoint(p2), unwrapJoinPoint(p3), unwrapJoinPoint(p4))); }
}

export class OpAssignment extends Assignment {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "operator",
  };
  setOperator(operator: string): void { return wrapJoinPoint(this._javaObject.setOperator(unwrapJoinPoint(operator))); }
}

export class Pragma extends Comment {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
}

export class Return extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
}

export class SnippetStmt extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "kind",
  };
  setLine(line: number): void { return wrapJoinPoint(this._javaObject.setLine(unwrapJoinPoint(line))); }
}

export class XmlElement extends XmlNode {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: "name",
  };
  /**
   * A list of available attributes in this element
   */
  get attributeNames(): string[] { return wrapJoinPoint(this._javaObject.getAttributeNames()) }
  /**
   * The name (i.e., tag) of this element
   */
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  /**
   * The value associated with the given attribute
   */
  attribute(name: string): string { return wrapJoinPoint(this._javaObject.attribute(unwrapJoinPoint(name))); }
  setAttribute(name: string, value: string): string { return wrapJoinPoint(this._javaObject.setAttribute(unwrapJoinPoint(name), unwrapJoinPoint(value))); }
}

export enum LoopType {
  DOWHILE = "dowhile",
  FOR = "for",
  FOREACH = "foreach",
  WHILE = "while",
}

export enum CommentType {
  BLOCK = "block",
  FILE = "file",
  INLINE = "inline",
  JAVADOC = "javadoc",
  PRAGMA = "pragma",
}

export enum RefType {
  DECL = "decl",
  READ = "read",
  READWRITE = "readwrite",
  WRITE = "write",
}

const JoinpointMapper = {
  joinpoint: Joinpoint,
  NamedType: NamedType,
  app: App,
  catch: Catch,
  declaration: Declaration,
  executable: Executable,
  expression: Expression,
  field: Field,
  file: FileJp,
  libClass: LibClass,
  libMethod: LibMethod,
  literal: Literal,
  method: Method,
  new: New,
  reference: Reference,
  snippetExpr: SnippetExpr,
  statement: Statement,
  switch: Switch,
  ternary: Ternary,
  this: This,
  throw: Throw,
  try: Try,
  type: Type,
  typeReference: TypeReference,
  unaryExpression: UnaryExpression,
  var: Var,
  xmlNode: XmlNode,
  androidManifest: AndroidManifest,
  annotation: Annotation,
  anonymousExec: AnonymousExec,
  arrayAccess: ArrayAccess,
  assert: Assert,
  assignment: Assignment,
  binaryExpression: BinaryExpression,
  body: Body,
  break: Break,
  call: Call,
  callStatement: CallStatement,
  case: Case,
  class: Class,
  comment: Comment,
  constructor: Constructor,
  continue: Continue,
  enum: Enum,
  enumValue: EnumValue,
  fieldAccess: FieldAccess,
  if: If,
  interfaceType: InterfaceType,
  localVariable: LocalVariable,
  loop: Loop,
  opAssignment: OpAssignment,
  pragma: Pragma,
  return: Return,
  snippetStmt: SnippetStmt,
  xmlElement: XmlElement,
};

let registered = false;
if (!registered) {
  registerJoinpointMapper(JoinpointMapper);
  registered = true;
}

